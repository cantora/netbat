#!/usr/bin/env ruby

module Netbat; end

THIS_DIR = File.expand_path(File.dirname(__FILE__))
$: << File.join(THIS_DIR, "..")

require 'netbat/datagram'
require 'netbat/datagram/xmpp_socket'
require 'netbat/client_ctx'
require 'netbat/server_ctx'
require 'netbat/protobuf/netbat.pb'
require 'netbat/log'
require 'netbat/public'
require 'netbat/proto_proc'
require 'netbat/socket'
require 'netbat/tun'

require 'optparse'
require 'uri'
require 'logger'


module Netbat
	
	class Cmd

		SB_TYPES = [:xmpp]

		PROCS = []
		ProtoProcDesc::procedures.each do |k,v|
			next if k == "INFO"
			PROCS << k
		end
						
		def self.parse(argv)
			options = {
				:verbose 			=> 0,
				:cx_amt				=> 1,
				:sb_type			=> :xmpp,
				:xmpp_sub			=> false
			}
												
			optparse = OptionParser.new do |opts|
				opts.banner = "usage: #{File.basename(__FILE__)} [options] SRC-ADDR [DST-ADDR]"
				opts.separator ""

				opts.on('-l', '--listen', 'wait for incoming connections' ) do |listen|
					options[:listen] = listen
				end
				
				n_desc = [
					"amount of connections to accept (0 => unlimited).",
					"default: #{options[:cx_amt].inspect}" 
				].join(" ")
				opts.on('-n', '--cx-amt N', Integer, n_desc) do |amt|
					options[:cx_amt] = (amt < 0)? 1 : amt
				end
				
				b_desc = [
					"use TYPE for side band. default: #{options[:sb_type].inspect}",
					#"#{"\t"*5}types: #{SB_TYPES.join(",")}"
				].join("\n")

				opts.on('-b', '--side-band TYPE', SB_TYPES, b_desc) do |sb|
					options[:side_band] = sb
				end

				opts.on('--addr IP', "specify public IP address of local host") do |ip|
					options[:addr] = ip
				end

				host_types = Netbat::Msg::HostType.constants.map {|x| x.to_s}
				options[:host_type] = :UNKNOWN
				t_desc = "type of host: #{host_types.join(", ")}. default: #{options[:host_type].inspect}"
				opts.on('-t', '--host-type TYPE', host_types, t_desc) do |ht|
					options[:host_type] = ht.to_sym
				end

				opts.on("--v4", "attempt to discover public ipv4 address and exit.") do |bul|
					options[:v4_addr] = bul
				end
	
				v4port_desc = "attempt to discover public ipv4 address and example public source port, then exit."
				opts.on("--v4-port PORT", Integer, v4port_desc) do |port|
					options[:v4_port] = port
				end

				options[:cx_procs] = [PROCS[0]]
				p_first = true
				p_desc = "connection procedures: #{PROCS.join(", ")}. default: #{options[:cx_procs].join(", ")}"
				opts.on('-p', '--cx-proc PROC', PROCS, p_desc) do |cp|
					options[:cx_procs] = [] if p_first == true
					options[:cx_procs] << cp
				end

				k_desc = "emit messages every INTERVAL seconds to help persist tunnels/connections"
				opts.on('-k', '--keepalive INTERVAL', Integer, k_desc) do |interval|
					options[:keepalive] = interval
				end

				c_desc = "pipe established connection to ADDR:PORT"
				opts.on('-c', '--connect ADDR:PORT', c_desc) do |dest|
					addr, port = dest.split(":", 2)
					raise "-c: empty address" if addr.empty?
					raise "-c: empty port" if port.empty?
					port = port.to_i
					raise "-c: invalid port: #{port.inspect}" if !(1..(2**16)-1).include?(port)
					options[:connect] = [addr, port]
				end
				
				opts.separator ""
				opts.separator "xmpp options:"
				xmpp_sub_desc = "subscribe to DST-ADDR before connecting. default: #{options[:xmpp_sub].inspect}"
				opts.on('--[no-]xmpp-sub', xmpp_sub_desc) do |xmpp_sub|
					options[:xmpp_sub] = xmpp_sub
				end

				opts.separator ""
				opts.separator "common options:"

				opts.on('-v', '--verbose', 'verbose output') do
					options[:verbose] += 1
				end

				h_help = 'display this message. if PROC is passed, output the usage for PROC.'
				opts.on('-h', '--help [PROC]', h_help) do |cx_proc|
					if PROCS.include?(cx_proc)
						klass = ProtoProcDesc::procedures[cx_proc]
						if klass.nil?
							raise "no such connection procedure: #{cx_proc}"
						else
							raise klass.usage()
						end
					else
						raise ""
					end
				end
			end
			
			begin
				optparse.parse!(argv)
				
				if !options[:v4_addr] && !options.include?(:v4_port)
					options[:src_addr] = argv.shift
					if options[:src_addr].nil? || options[:src_addr].strip.empty?
						raise "invalid SRC-ADDR: #{options[:src_addr].inspect}" 
					end
					options[:src_addr], options[:src_auth] = begin
						src_addr_and_auth(options, options[:src_addr])
					rescue ArgumentError => e
						raise "invalid source address: #{e.message}"
					end
	
					if options[:listen].nil?
						options[:dst_addr] = argv.shift
						if options[:dst_addr].nil? || options[:dst_addr].strip.empty?
							raise "invalid DST-ADDR: #{options[:dst_addr].inspect}"
						end
	
						options[:dst_addr] = begin
							dst_addr(options, options[:dst_addr])
						rescue ArgumentError => e
							raise "invalid destination address: #{e.message}"
						end
					end
	
					if !Netbat::Msg::HostType.constants.include?(options[:host_type])
						raise "must provide valid host type. got: #{options[:host_type].inspect}"
					end
				else #public address discovery
					if options.include?(:v4_port)
						if !(1025..(2**16-1)).include?(options[:v4_port])
							raise "invalid port number: #{@options[:v4_port].inspect}"
						end
					end
				end

			rescue Exception => e
				puts e.message if !e.message.empty?
				puts optparse
				
				exit
			end	
			
			return options
		end #self.parse

		def self.src_addr_and_auth(options, uri_str)
			u = URI.parse(uri_str)

			case options[:sb_type]
			when :xmpp
				addr, auth = Datagram::XMPPSocket::XMPPAddr.uri_to_addr_and_auth(u)
				raise ArgumentError.new, "empty resource" if addr.resource.empty?
				return addr, auth
			else
				raise "shouldnt get here"				
			end
		end

		def self.dst_addr(options, uri_str)
			u = URI.parse(uri_str)

			case options[:sb_type]
			when :xmpp
				addr = Datagram::XMPPSocket::XMPPAddr.from_uri(u)
				raise ArgumentError.new, "empty resource" if addr.resource.empty?
				return addr
			else
				raise "shouldnt get here"				
			end
		end

		def initialize(options)
			@options = options
			@log = Logger.new($stderr)
			@log.formatter = proc do |sev, t, pname, msg|
				Thread.current.object_id.to_s(16) + ":" + msg + "\n"
			end

			@log.level = case @options[:verbose]
			when 0
				Logger::WARN
			when 1
				Logger::INFO
			else
				Logger::DEBUG
			end
			Netbat::LOG.level = @log.level

		end
		
		def public_addr()
			begin 
				if @options[:v4_port]
					addr, port = Public::ipv4_port_test(@options[:v4_port])
					puts "*:#{@options[:v4_port]} => #{addr}:#{port}"
				else
					puts Public::ipv4()
				end
			rescue Public::DiscoveryException => e
				$stderr.puts e.message
			end
		end

		def run()
			if @options[:v4_addr] || @options.include?(:v4_port)
				public_addr()	
			else 
				if @options[:listen]
					cmd_listen
				else
					cmd_connect
				end	
			end
		end

		def bind_datagram(bind_addr, auth)
			sock = case @options[:sb_type]
			when :xmpp
				Datagram::XMPPSocket.new(bind_addr, auth)
			else
				raise "invalid side band type: #{@options[:sb_type].inspect}"
			end

			sock.on_bind do 
				@log.info "bound datagram to addr: #{sock.addr.inspect}"
			end
			sock.bind

			return sock
		end

		def cmd_listen
			@log.debug "cmd_listen"
			@log.debug Netbat::thread_list()
			sock = bind_datagram(@options[:src_addr], @options[:src_auth])
			@log.debug Netbat::thread_list()

			local_info = LocalInfo.new(@options[:host_type], Msg::OpCode.constants, :ipv4 => @options[:addr])
			local_info.freeze

			@log.debug "local info: #{local_info.inspect}"
			dmx = Datagram::Demuxer.new(sock) do |peer, first_msg, active|
				@log.info "new connection from #{peer.to_s}"
				
				if active.size < 1
					ctx = ServerCtx.new(sock, peer, local_info)
					ctx.recv(first_msg)
	
					ctx
				else
					@log.debug "dropped connection"
					nil
				end
			end
			
			result = nil
			dmx.on_clock do |ctx|
				result = ctx.clock()
				if result.is_a?(PunchProcDesc::PunchedUDP)
					@log.debug "got result. close OOB socket"
					sock.close 
					@log.debug "closed OOB socket"
				end
			end

			dmx.demux do |ctx, msg|
				@log.debug "message #{ctx.peer_seq} from #{ctx.peer_addr.inspect}: #{msg.inspect}"

				if msg.is_a?(Datagram::Socket::Error)
					ctx.recv_err(msg)
				else
					ctx.recv(msg)
				end
			end
	
			if result.nil?
				raise "result shouldnt be nil"
			end
			
			@log.debug "result: #{result.inspect}"
			$stderr.puts "connected to udp #{result.addr}:#{result.port}"
			action_switch(result)
		end

		def cmd_connect
			@log.debug "cmd_connect"
			local_info = LocalInfo.new(
				@options[:host_type], 
				Msg::OpCode.constants,
				:ipv4 => @options[:addr]
			)
			local_info.freeze

			sock = bind_datagram(@options[:src_addr], @options[:src_auth])
			peer_addr = @options[:dst_addr]
			ctx = ClientCtx.new(sock, peer_addr, local_info)
			
			filter = Datagram::Filter.new(sock, peer_addr) 

			filter.on_msg do |msg|
				begin
					ctx.recv(msg)
				rescue Exception => e
					$stderr.puts Netbat::exception_str("fatal exception in recv handler: #{e.inspect}", e)
					exit!(1)
				end
			end

			filter.on_err do |err|
				begin
					ctx.recv_err(err)
				rescue Exception => e
					$stderr.puts Netbat::exception_str("fatal exception in recv_err handler: #{e.inspect}", e)
					exit!(1)
				end
			end

			pudp = begin
				ctx.run(@options[:cx_procs].map {|name| ProtoProcDesc::procedures[name]})
			rescue ClientCtx::AllProceduresFailed => e
				$stderr.puts "all methods failed to establish connection: #{e.message}"
				return
			rescue ProtoProc::StandardException => e
				$stderr.puts "general failure: #{e.message}"
				return 
			rescue Exception => e
				$stderr.puts Netbat::exception_str("fatal exception in run loop", e)
				exit!(1)
			end

			@log.debug "got result: #{pudp.inspect}"
			$stderr.puts "connected to udp #{pudp.addr}:#{pudp.port}"

			action_switch(pudp)
		end

		def action_switch(pudp)
			if @options[:connect]
				action_connect(pudp)
			else
				action_io(pudp)
			end
		end

		#bloc should be a function that reads from whatever
		#we are pipeing to. it can block.
		def pipe_pudp(pudp, out_io, &bloc) 

			Thread.new do
				Thread.current.abort_on_exception = true

				loop do
					data = pudp.rcv()
					out_io.write(data) if data.size > 0
				end
			end

			Thread.new do
				#ping to help keep the NAT port forwarding active
				loop do 
					pudp.snd("")
					time = @options[:keepalive]
					time = 1 if time < 1
					sleep(time)
				end
			end if @options[:keepalive]

			loop do 
				pudp.snd(bloc.call())
			end
		end

		def action_io(pudp)
			pipe_pudp(pudp, $stdout) do 
				$stdin.readline()
			end
		end

		def action_connect(pudp)
			
			u = UDPSocket.new()
						
			sock = UDPio.new(u, @options[:connect][0], @options[:connect][1])

			pipe_pudp(pudp, sock) do 
				#@log.debug "block on socket read"
				data = sock.read()
				#@log.debug "read returned #{data.size} bytes"
				data
			end
		end

	end #Cmd
end


if $0 == __FILE__
	options = Netbat::Cmd::parse(ARGV)
	nb = Netbat::Cmd.new(options)
	nb.run
end